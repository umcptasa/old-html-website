{"version":3,"sources":["../../src/query/queue.js"],"names":["Queue","require","store","FastMemoryStore","queryRunner","websocketManager","GraphQLRunner","createBaseOptions","concurrent","createBuildQueue","graphqlRunner","handler","queryJob","callback","then","result","catch","createDevelopQueue","getRunner","queue","processing","Set","waiting","Map","queueOptions","priority","job","cb","activePaths","Array","from","values","id","includes","merge","oldTask","newTask","filter","has","set","isPage","emitPageData","emitStaticQueryData","delete","push","get","error","pushJob","Promise","resolve","reject","on","processBatch","jobs","numJobs","length","runningJobs","map","all","module","exports"],"mappings":"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","sourcesContent":["const Queue = require(`better-queue`)\nconst { store } = require(`../redux`)\nconst FastMemoryStore = require(`../query/better-queue-custom-store`)\nconst queryRunner = require(`../query/query-runner`)\nconst websocketManager = require(`../utils/websocket-manager`)\nconst GraphQLRunner = require(`./graphql-runner`)\n\nconst createBaseOptions = () => {\n  return {\n    concurrent: 4,\n    store: FastMemoryStore(),\n  }\n}\n\nconst createBuildQueue = () => {\n  const graphqlRunner = new GraphQLRunner(store)\n  const handler = (queryJob, callback) =>\n    queryRunner(graphqlRunner, queryJob)\n      .then(result => callback(null, result))\n      .catch(callback)\n  return new Queue(handler, createBaseOptions())\n}\n\nconst createDevelopQueue = getRunner => {\n  let queue\n  const processing = new Set()\n  const waiting = new Map()\n\n  const queueOptions = {\n    ...createBaseOptions(),\n    priority: (job, cb) => {\n      const activePaths = Array.from(websocketManager.activePaths.values())\n      if (job.id && activePaths.includes(job.id)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    merge: (oldTask, newTask, cb) => {\n      cb(null, newTask)\n    },\n    // Filter out new query jobs if that query is already running.\n    // When the query finshes, it checks the waiting map and pushes\n    // another job to make sure all the user changes are captured.\n    filter: (job, cb) => {\n      if (processing.has(job.id)) {\n        waiting.set(job.id, job)\n        cb(`already running`)\n      } else {\n        cb(null, job)\n      }\n    },\n  }\n\n  const handler = (queryJob, callback) => {\n    queryRunner(getRunner(), queryJob).then(\n      result => {\n        if (queryJob.isPage) {\n          websocketManager.emitPageData({\n            result,\n            id: queryJob.id,\n          })\n        } else {\n          websocketManager.emitStaticQueryData({\n            result,\n            id: queryJob.id,\n          })\n        }\n\n        processing.delete(queryJob.id)\n        if (waiting.has(queryJob.id)) {\n          queue.push(waiting.get(queryJob.id))\n          waiting.delete(queryJob.id)\n        }\n        callback(null, result)\n      },\n      error => callback(error)\n    )\n  }\n\n  queue = new Queue(handler, queueOptions)\n  return queue\n}\n\nconst pushJob = (queue, job) =>\n  new Promise((resolve, reject) =>\n    queue\n      .push(job)\n      .on(`finish`, resolve)\n      .on(`failed`, reject)\n  )\n\n/**\n * Returns a promise that pushes jobs onto queue and resolves onces\n * they're all finished processing (or rejects if one or more jobs\n * fail)\n */\nconst processBatch = async (queue, jobs) => {\n  let numJobs = jobs.length\n  if (numJobs === 0) {\n    return Promise.resolve()\n  }\n  const runningJobs = jobs.map(job => pushJob(queue, job))\n  return await Promise.all(runningJobs)\n}\n\nmodule.exports = {\n  createBuildQueue,\n  createDevelopQueue,\n  processBatch,\n}\n"],"file":"queue.js"}