{"version":3,"sources":["../../src/schema/node-model.js"],"names":["_","require","isAbstractType","GraphQLOutputType","GraphQLUnionType","GraphQLList","getNamedType","getNullableType","isCompositeType","invariant","reporter","LocalNodeModel","constructor","schema","schemaComposer","nodeStore","createPageDependency","_rootNodeMap","WeakMap","_trackedRootNodes","Set","_prepareNodesQueues","_prepareNodesPromises","_preparedNodesCache","Map","withContext","context","ContextualNodeModel","getNodeById","args","pageDependencies","id","type","node","result","nodeTypeNames","toNodeTypeNames","includes","internal","trackInlineObjectsInRootNode","trackPageDependencies","getNodesByIds","ids","nodes","Array","isArray","map","filter","Boolean","length","forEach","getAllNodes","getNodes","reduce","acc","typeName","push","getNodesByType","runQuery","query","firstOnly","gqlType","getType","fields","getQueryFields","sort","group","distinct","fieldsToResolve","determineResolvableFields","name","prepareNodes","queryResult","queryArgs","gqlSchema","gqlComposer","resolvedFields","queryFields","Promise","resolve","process","nextTick","_doResolvePrepareNodesQueue","queue","nextQueryFields","nextFieldsToResolve","merge","actualFieldsToResolve","deepObjectDifference","get","isEmpty","saveResolvedNodes","resolveRecursive","mergedResolved","__gatsby_resolved","set","getTypes","has","addRootNodeToInlineObject","add","findRootNodeAncestor","obj","predicate","iterations","parent","trackedParent","error","path","connectionType","connection","nodeId","rootNodeModel","nodeModel","fullDependencies","getNode","gqlTypeName","possibleTypes","getPossibleTypes","getInterfaces","some","iface","filterFields","dropQueryOperators","sortFields","pathToObject","split","reduceRight","key","Object","keys","value","k","v","isPlainObject","getFields","concreteType","resolveType","gqlFields","fieldName","fieldToResolve","queryField","gqlField","gqlNonNullType","gqlFieldType","innerValue","resolveField","isObject","all","item","pickBy","withResolverContext","arg","defaultValue","returnType","field","typeComposer","getAnyTC","needsResolve","getFieldExtension","innerResolved","rootNodeMap","data","isNode","each","o","from","to","toValue","deepResult","module","exports"],"mappings":"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","sourcesContent":["// @flow\n\nconst _ = require(`lodash`)\nconst {\n  isAbstractType,\n  GraphQLOutputType,\n  GraphQLUnionType,\n  GraphQLList,\n  getNamedType,\n  getNullableType,\n  isCompositeType,\n} = require(`graphql`)\nconst invariant = require(`invariant`)\nconst reporter = require(`gatsby-cli/lib/reporter`)\n\ntype TypeOrTypeName = string | GraphQLOutputType\n\n/**\n * Optional page dependency information.\n *\n * @typedef {Object} PageDependencies\n * @property {string} path The path of the page that depends on the retrieved nodes' data\n * @property {string} [connectionType] Mark this dependency as a connection\n */\ninterface PageDependencies {\n  path: string;\n  connectionType?: string;\n}\n\ninterface QueryArguments {\n  type: TypeOrTypeName;\n  query: { filter: Object, sort?: Object };\n  firstOnly?: boolean;\n}\n\nexport interface NodeModel {\n  getNodeById(\n    { id: string, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): any | null;\n  getNodesByIds(\n    { ids: Array<string>, type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  getAllNodes(\n    { type?: TypeOrTypeName },\n    pageDependencies?: PageDependencies\n  ): Array<any>;\n  runQuery(\n    args: QueryArguments,\n    pageDependencies?: PageDependencies\n  ): Promise<any>;\n  getTypes(): Array<string>;\n  trackPageDependencies<nodeOrNodes: Node | Node[]>(\n    result: nodeOrNodes,\n    pageDependencies?: PageDependencies\n  ): nodesOrNodes;\n  findRootNodeAncestor(obj: any, predicate: () => boolean): Node | null;\n  trackInlineObjectsInRootNode(node: Node, sanitize: boolean): Node;\n}\n\nclass LocalNodeModel {\n  constructor({ schema, schemaComposer, nodeStore, createPageDependency }) {\n    this.schema = schema\n    this.schemaComposer = schemaComposer\n    this.nodeStore = nodeStore\n    this.createPageDependency = createPageDependency\n\n    this._rootNodeMap = new WeakMap()\n    this._trackedRootNodes = new Set()\n    this._prepareNodesQueues = {}\n    this._prepareNodesPromises = {}\n    this._preparedNodesCache = new Map()\n  }\n\n  withContext(context) {\n    return new ContextualNodeModel(this, context)\n  }\n\n  /**\n   * Get a node from the store by ID and optional type.\n   *\n   * @param {Object} args\n   * @param {string} args.id ID of the requested node\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the node\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {(Node|null)}\n   */\n  getNodeById(args, pageDependencies) {\n    const { id, type } = args || {}\n\n    const node = getNodeById(this.nodeStore, id)\n\n    let result\n    if (!node) {\n      result = null\n    } else if (!type) {\n      result = node\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodeTypeNames.includes(node.internal.type) ? node : null\n    }\n\n    if (result) {\n      this.trackInlineObjectsInRootNode(node)\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  /**\n   * Get nodes from the store by IDs and optional type.\n   *\n   * @param {Object} args\n   * @param {string[]} args.ids IDs of the requested nodes\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   */\n  getNodesByIds(args, pageDependencies) {\n    const { ids, type } = args || {}\n\n    const nodes = Array.isArray(ids)\n      ? ids.map(id => getNodeById(this.nodeStore, id)).filter(Boolean)\n      : []\n\n    let result\n    if (!nodes.length || !type) {\n      result = nodes\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      result = nodes.filter(node => nodeTypeNames.includes(node.internal.type))\n    }\n\n    if (result) {\n      result.forEach(node => this.trackInlineObjectsInRootNode(node))\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  /**\n   * Get all nodes in the store, or all nodes of a specified type. Note that\n   * this doesn't add tracking to all the nodes, unless pageDependencies are\n   * passed.\n   *\n   * @param {Object} args\n   * @param {(string|GraphQLOutputType)} [args.type] Optional type of the nodes\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node[]}\n   */\n  getAllNodes(args, pageDependencies) {\n    const { type } = args || {}\n\n    let result\n    if (!type) {\n      result = this.nodeStore.getNodes()\n    } else {\n      const nodeTypeNames = toNodeTypeNames(this.schema, type)\n      const nodes = nodeTypeNames.reduce((acc, typeName) => {\n        acc.push(...this.nodeStore.getNodesByType(typeName))\n        return acc\n      }, [])\n      result = nodes.filter(Boolean)\n    }\n\n    if (result) {\n      result.forEach(node => this.trackInlineObjectsInRootNode(node))\n    }\n\n    if (pageDependencies) {\n      return this.trackPageDependencies(result, pageDependencies)\n    } else {\n      return result\n    }\n  }\n\n  /**\n   * Get nodes of a type matching the specified query.\n   *\n   * @param {Object} args\n   * @param {Object} args.query Query arguments (`filter` and `sort`)\n   * @param {(string|GraphQLOutputType)} args.type Type\n   * @param {boolean} [args.firstOnly] If true, return only first match\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Promise<Node[]>}\n   */\n  async runQuery(args, pageDependencies) {\n    const { query, firstOnly, type } = args || {}\n\n    // We don't support querying union types (yet?), because the combined types\n    // need not have any fields in common.\n    const gqlType = typeof type === `string` ? this.schema.getType(type) : type\n    invariant(\n      !(gqlType instanceof GraphQLUnionType),\n      `Querying GraphQLUnion types is not supported.`\n    )\n\n    const fields = getQueryFields({\n      filter: query.filter,\n      sort: query.sort,\n      group: query.group,\n      distinct: query.distinct,\n    })\n    const fieldsToResolve = determineResolvableFields(\n      this.schemaComposer,\n      this.schema,\n      gqlType,\n      fields\n    )\n\n    let nodeTypeNames\n    if (isAbstractType(gqlType)) {\n      nodeTypeNames = toNodeTypeNames(this.schema, gqlType)\n    } else {\n      nodeTypeNames = [gqlType.name]\n    }\n\n    await this.prepareNodes(gqlType, fields, fieldsToResolve, nodeTypeNames)\n\n    const queryResult = await this.nodeStore.runQuery({\n      queryArgs: query,\n      firstOnly,\n      gqlSchema: this.schema,\n      gqlComposer: this.schemaComposer,\n      gqlType,\n      resolvedFields: fieldsToResolve,\n      nodeTypeNames,\n    })\n\n    let result = queryResult\n    if (args.firstOnly) {\n      if (result && result.length > 0) {\n        result = result[0]\n        this.trackInlineObjectsInRootNode(result)\n      } else {\n        result = null\n      }\n    } else if (result) {\n      result.forEach(node => this.trackInlineObjectsInRootNode(node))\n    }\n\n    return this.trackPageDependencies(result, pageDependencies)\n  }\n\n  prepareNodes(type, queryFields, fieldsToResolve, nodeTypeNames) {\n    const typeName = type.name\n    if (!this._prepareNodesQueues[typeName]) {\n      this._prepareNodesQueues[typeName] = []\n    }\n\n    this._prepareNodesQueues[typeName].push({\n      queryFields,\n      fieldsToResolve,\n    })\n\n    if (!this._prepareNodesPromises[typeName]) {\n      this._prepareNodesPromises[typeName] = new Promise(resolve => {\n        process.nextTick(async () => {\n          await this._doResolvePrepareNodesQueue(type, nodeTypeNames)\n          resolve()\n        })\n      })\n    }\n\n    return this._prepareNodesPromises[typeName]\n  }\n\n  async _doResolvePrepareNodesQueue(type, nodeTypeNames) {\n    const typeName = type.name\n    const queue = this._prepareNodesQueues[typeName]\n    this._prepareNodesQueues[typeName] = []\n    this._prepareNodesPromises[typeName] = null\n\n    const { queryFields, fieldsToResolve } = queue.reduce(\n      (\n        { queryFields, fieldsToResolve },\n        { queryFields: nextQueryFields, fieldsToResolve: nextFieldsToResolve }\n      ) => {\n        return {\n          queryFields: _.merge(queryFields, nextQueryFields),\n          fieldsToResolve: _.merge(fieldsToResolve, nextFieldsToResolve),\n        }\n      },\n      {\n        queryFields: {},\n        fieldsToResolve: {},\n      }\n    )\n\n    const actualFieldsToResolve = deepObjectDifference(\n      fieldsToResolve,\n      this._preparedNodesCache.get(typeName) || {}\n    )\n\n    if (!_.isEmpty(actualFieldsToResolve)) {\n      await this.nodeStore.saveResolvedNodes(nodeTypeNames, async node => {\n        this.trackInlineObjectsInRootNode(node)\n        const resolvedFields = await resolveRecursive(\n          this,\n          this.schemaComposer,\n          this.schema,\n          node,\n          type,\n          queryFields,\n          actualFieldsToResolve\n        )\n        const mergedResolved = _.merge(\n          node.__gatsby_resolved || {},\n          resolvedFields\n        )\n        return mergedResolved\n      })\n      this._preparedNodesCache.set(\n        typeName,\n        _.merge(\n          {},\n          this._preparedNodesCache.get(typeName) || {},\n          actualFieldsToResolve\n        )\n      )\n    }\n  }\n\n  /**\n   * Get the names of all node types in the store.\n   *\n   * @returns {string[]}\n   */\n  getTypes() {\n    return this.nodeStore.getTypes()\n  }\n\n  /**\n   * Adds link between inline objects/arrays contained in Node object\n   * and that Node object.\n   * @param {Node} node Root Node\n   */\n  trackInlineObjectsInRootNode(node) {\n    if (!this._trackedRootNodes.has(node.id)) {\n      addRootNodeToInlineObject(this._rootNodeMap, node, node.id, true, true)\n      this._trackedRootNodes.add(node.id)\n    }\n  }\n\n  /**\n   * Finds top most ancestor of node that contains passed Object or Array\n   * @param {(Object|Array)} obj Object/Array belonging to Node object or Node object\n   * @param {nodePredicate} [predicate] Optional callback to check if ancestor meets defined conditions\n   * @returns {Node} Top most ancestor if predicate is not specified\n   * or first node that meet predicate conditions if predicate is specified\n   */\n  findRootNodeAncestor(obj, predicate = null) {\n    let iterations = 0\n    let node = obj\n\n    while (iterations++ < 100) {\n      if (predicate && predicate(node)) return node\n\n      const parent = node.parent && getNodeById(this.nodeStore, node.parent)\n      const id = this._rootNodeMap.get(node)\n      const trackedParent = id && getNodeById(this.nodeStore, id)\n\n      if (!parent && !trackedParent) return node\n\n      node = parent || trackedParent\n    }\n\n    reporter.error(\n      `It looks like you have a node that's set its parent as itself:\\n\\n` +\n        node\n    )\n    return null\n  }\n\n  /**\n   * Given a result, that's either a single node or an array of them, track them\n   * using pageDependencies. Defaults to tracking according to current resolver\n   * path. Returns the result back.\n   *\n   * @param {Node | Node[]} result\n   * @param {PageDependencies} [pageDependencies]\n   * @returns {Node | Node[]}\n   */\n  trackPageDependencies(result, pageDependencies = {}) {\n    const { path, connectionType } = pageDependencies\n    if (path) {\n      if (connectionType) {\n        this.createPageDependency({ path, connection: connectionType })\n      } else {\n        const nodes = Array.isArray(result) ? result : [result]\n        for (const node of nodes) {\n          if (node) {\n            this.createPageDependency({ path, nodeId: node.id })\n          }\n        }\n      }\n    }\n\n    return result\n  }\n}\n\nclass ContextualNodeModel {\n  constructor(rootNodeModel, context) {\n    this.nodeModel = rootNodeModel\n    this.context = context\n  }\n\n  withContext(context) {\n    return new ContextualNodeModel(this.nodeModel, {\n      ...this.context,\n      ...context,\n    })\n  }\n\n  getNodeById(...args) {\n    return this.nodeModel.getNodeById(...args)\n  }\n\n  getNodesByIds(...args) {\n    return this.nodeModel.getNodesByIds(...args)\n  }\n\n  getAllNodes(...args) {\n    return this.nodeModel.getAllNodes(...args)\n  }\n\n  runQuery(...args) {\n    return this.nodeModel.runQuery(...args)\n  }\n  prepareNodes(...args) {\n    return this.nodeModel.prepareNodes(...args)\n  }\n\n  getTypes(...args) {\n    return this.nodeModel.getTypes(...args)\n  }\n\n  trackInlineObjectsInRootNode(...args) {\n    return this.nodeModel.trackInlineObjectsInRootNode(...args)\n  }\n\n  findRootNodeAncestor(...args) {\n    return this.nodeModel.findRootNodeAncestor(...args)\n  }\n\n  createPageDependency(...args) {\n    return this.nodeModel.createPageDependency(...args)\n  }\n\n  trackPageDependencies(result, pageDependencies) {\n    const fullDependencies = {\n      path: this.context.path,\n      ...(pageDependencies || {}),\n    }\n\n    return this.nodeModel.trackPageDependencies(result, fullDependencies)\n  }\n}\n\nconst getNodeById = (nodeStore, id) =>\n  id != null ? nodeStore.getNode(id) : null\n\nconst toNodeTypeNames = (schema, gqlTypeName) => {\n  const gqlType =\n    typeof gqlTypeName === `string` ? schema.getType(gqlTypeName) : gqlTypeName\n\n  if (!gqlType) return []\n\n  const possibleTypes = isAbstractType(gqlType)\n    ? schema.getPossibleTypes(gqlType)\n    : [gqlType]\n\n  return possibleTypes\n    .filter(type => type.getInterfaces().some(iface => iface.name === `Node`))\n    .map(type => type.name)\n}\n\nconst getQueryFields = ({ filter, sort, group, distinct }) => {\n  const filterFields = filter ? dropQueryOperators(filter) : {}\n  const sortFields = (sort && sort.fields) || []\n\n  if (group && !Array.isArray(group)) {\n    group = [group]\n  } else if (group == null) {\n    group = []\n  }\n\n  if (distinct && !Array.isArray(distinct)) {\n    distinct = [distinct]\n  } else if (distinct == null) {\n    distinct = []\n  }\n\n  return _.merge(\n    filterFields,\n    ...sortFields.map(pathToObject),\n    ...group.map(pathToObject),\n    ...distinct.map(pathToObject)\n  )\n}\n\nconst pathToObject = path => {\n  if (path && typeof path === `string`) {\n    return path.split(`.`).reduceRight((acc, key) => {\n      return { [key]: acc }\n    }, true)\n  }\n  return {}\n}\n\nconst dropQueryOperators = filter =>\n  Object.keys(filter).reduce((acc, key) => {\n    const value = filter[key]\n    const k = Object.keys(value)[0]\n    const v = value[k]\n    if (_.isPlainObject(value) && _.isPlainObject(v)) {\n      acc[key] =\n        k === `elemMatch` ? dropQueryOperators(v) : dropQueryOperators(value)\n    } else {\n      acc[key] = true\n    }\n    return acc\n  }, {})\n\nconst getFields = (schema, type, node) => {\n  if (!isAbstractType(type)) {\n    return type.getFields()\n  }\n\n  const concreteType = type.resolveType(node)\n  return schema.getType(concreteType).getFields()\n}\n\nasync function resolveRecursive(\n  nodeModel,\n  schemaComposer,\n  schema,\n  node,\n  type,\n  queryFields,\n  fieldsToResolve\n) {\n  const gqlFields = getFields(schema, type, node)\n  let resolvedFields = {}\n  for (const fieldName of Object.keys(fieldsToResolve)) {\n    const fieldToResolve = fieldsToResolve[fieldName]\n    const queryField = queryFields[fieldName]\n    const gqlField = gqlFields[fieldName]\n    const gqlNonNullType = getNullableType(gqlField.type)\n    const gqlFieldType = getNamedType(gqlField.type)\n    let innerValue\n    if (gqlField.resolve) {\n      innerValue = await resolveField(\n        nodeModel,\n        schemaComposer,\n        schema,\n        node,\n        gqlField,\n        fieldName\n      )\n    } else {\n      innerValue = node[fieldName]\n    }\n    if (gqlField && innerValue != null) {\n      if (\n        isCompositeType(gqlFieldType) &&\n        !(gqlNonNullType instanceof GraphQLList)\n      ) {\n        innerValue = await resolveRecursive(\n          nodeModel,\n          schemaComposer,\n          schema,\n          innerValue,\n          gqlFieldType,\n          queryField,\n          _.isObject(fieldToResolve) ? fieldToResolve : queryField\n        )\n      } else if (\n        isCompositeType(gqlFieldType) &&\n        _.isArray(innerValue) &&\n        gqlNonNullType instanceof GraphQLList\n      ) {\n        innerValue = await Promise.all(\n          innerValue.map(item =>\n            resolveRecursive(\n              nodeModel,\n              schemaComposer,\n              schema,\n              item,\n              gqlFieldType,\n              queryField,\n              _.isObject(fieldToResolve) ? fieldToResolve : queryField\n            )\n          )\n        )\n      }\n    }\n    if (innerValue != null) {\n      resolvedFields[fieldName] = innerValue\n    }\n  }\n\n  Object.keys(queryFields).forEach(key => {\n    if (!fieldsToResolve[key] && node[key]) {\n      resolvedFields[key] = node[key]\n    }\n  })\n\n  return _.pickBy(resolvedFields, (value, key) => queryFields[key])\n}\n\nfunction resolveField(\n  nodeModel,\n  schemaComposer,\n  schema,\n  node,\n  gqlField,\n  fieldName\n) {\n  const withResolverContext = require(`./context`)\n  return gqlField.resolve(\n    node,\n    gqlField.args.reduce((acc, arg) => {\n      acc[arg.name] = arg.defaultValue\n      return acc\n    }, {}),\n    withResolverContext({\n      schema,\n      schemaComposer,\n      nodeModel,\n    }),\n    {\n      fieldName,\n      schema,\n      returnType: gqlField.type,\n    }\n  )\n}\n\nconst determineResolvableFields = (schemaComposer, schema, type, fields) => {\n  const fieldsToResolve = {}\n  const gqlFields = type.getFields()\n  Object.keys(fields).forEach(fieldName => {\n    const field = fields[fieldName]\n    const gqlField = gqlFields[fieldName]\n    const gqlFieldType = getNamedType(gqlField.type)\n    const typeComposer = schemaComposer.getAnyTC(type.name)\n    const needsResolve = typeComposer.getFieldExtension(\n      fieldName,\n      `needsResolve`\n    )\n    if (_.isObject(field) && gqlField) {\n      const innerResolved = determineResolvableFields(\n        schemaComposer,\n        schema,\n        gqlFieldType,\n        field\n      )\n      if (!_.isEmpty(innerResolved)) {\n        fieldsToResolve[fieldName] = innerResolved\n      }\n    }\n\n    if (!fieldsToResolve[fieldName] && needsResolve) {\n      fieldsToResolve[fieldName] = true\n    }\n  })\n  return fieldsToResolve\n}\n\nconst addRootNodeToInlineObject = (\n  rootNodeMap,\n  data,\n  nodeId,\n  isNode = false\n) => {\n  const isPlainObject = _.isPlainObject(data)\n\n  if (isPlainObject || _.isArray(data)) {\n    _.each(data, (o, key) => {\n      if (!isNode || key !== `internal`) {\n        addRootNodeToInlineObject(rootNodeMap, o, nodeId)\n      }\n    })\n    // don't need to track node itself\n    if (!isNode) {\n      rootNodeMap.set(data, nodeId)\n    }\n  }\n}\n\nconst deepObjectDifference = (from, to) => {\n  const result = {}\n  Object.keys(from).forEach(key => {\n    const toValue = to[key]\n    if (toValue) {\n      if (_.isPlainObject(toValue)) {\n        const deepResult = deepObjectDifference(from[key], toValue)\n        if (!_.isEmpty(deepResult)) {\n          result[key] = deepResult\n        }\n      }\n    } else {\n      result[key] = from[key]\n    }\n  })\n  return result\n}\n\nmodule.exports = {\n  LocalNodeModel,\n}\n"],"file":"node-model.js"}